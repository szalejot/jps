package edu.pjwstk.mherman.jps.parser;
 
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;

import java_cup.runtime.DefaultSymbolFactory;
import java_cup.runtime.Symbol;
import edu.pjwstk.mherman.jps.ast.auxname.*;
import edu.pjwstk.mherman.jps.ast.binary.*;
import edu.pjwstk.mherman.jps.ast.terminal.*;
import edu.pjwstk.mherman.jps.ast.unary.*;
import edu.pjwstk.jps.ast.*;

parser code {: 
	public Lexer lexer;
	private String expr;
	public IExpression RESULT;
	
	public SBAParser(String expr) {
		this.symbolFactory = new DefaultSymbolFactory();   
		this.expr = expr;
	}
	
	void setResult(IExpression exp) {
		this.RESULT = exp;
	}  

:};

init with {: 	    lexer = new Lexer(new StringReader(expr)); :};
scan with {:		return lexer.next_token(); :};


terminal Integer INTEGER_LITERAL;
terminal Double DOUBLE_LITERAL;
terminal Boolean BOOLEAN_LITERAL;
terminal String STRING_LITERAL;
terminal String IDENTIFIER_LITERAL;

terminal String PLUS;
terminal String MINUS;
terminal String MULTIPLY; 
terminal String DIVIDE;
terminal String AS;
terminal String COMMA;
terminal String BAG;

terminal String LEFT_ROUND_BRACKET;
terminal String RIGHT_ROUND_BRACKET;

non terminal IExpression goal;
non terminal IExpression expr;


//priority
precedence left PLUS, MINUS; 
precedence left MULTIPLY, DIVIDE;
precedence left BAG;
precedence left COMMA;
precedence left AS;
precedence left LEFT_ROUND_BRACKET, RIGHT_ROUND_BRACKET;

start with goal;

goal ::= expr:e		{: RESULT = e; parser.setResult(e); :} ;

expr  ::=
		expr:e1 PLUS:o expr:e2	{: RESULT = new PlusExpression(e1, e2); :}
	| 	expr:e1 MINUS:o expr:e2	{: RESULT = new MinusExpression(e1, e2); :}
	| 	expr:e1 AS:o expr:e2	{: RESULT = new AsExpression(e1, ((NameTerminal) e2).getName()); :}
	| 	expr:e1 MULTIPLY:o 	 expr:e2	{: RESULT = new MultiplyExpression(e1, e2); :}
	| 	expr:e1 DIVIDE:o	 expr:e2	{: RESULT = new DivideExpression(e1, e2); :}
	| 	expr:e1 COMMA:o	 expr:e2	{: RESULT = new CommaExpression(e1, e2); :}
	| 	BAG:o expr:e1	{: RESULT = new BagExpression(e1); :}
	| 	STRING_LITERAL:o {: RESULT = new StringTerminal((String)o); :}
	| 	BOOLEAN_LITERAL:o {: RESULT = new BooleanTerminal((Boolean)o); :}
	| 	IDENTIFIER_LITERAL:o {: RESULT = new NameTerminal((String)o); :}
	| 	DOUBLE_LITERAL:o {: RESULT = new DoubleTerminal((Double)o); :}
	| 	INTEGER_LITERAL:o {: RESULT = new IntegerTerminal((Integer)o); :}
	|	LEFT_ROUND_BRACKET:o expr:e1 RIGHT_ROUND_BRACKET {: RESULT = e1; :}
	;